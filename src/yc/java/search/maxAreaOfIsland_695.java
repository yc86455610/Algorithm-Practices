package yc.java.search;

/**
 * @program: Algorithm-Practices
 * @description: 查找最大的联通面积
 * @author: yc
 * @create: 2019-11-28 18:32
 *
 * dfs:深度优先搜索
 * bfs广度优先搜索一层一层遍历，每一层得到的所有新节点，都用队列存储起来以备下一次遍历的时候再遍历
 *
 * 而dfs深度优先搜索在得到一个新节点时立即对新节点进行遍历：
 * 从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；
 * 如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。
 * 返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
 *
 * 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
 * DFS 常用来求解这种 可达性 问题。
 *
 * 在程序实现 DFS 时需要考虑以下问题：
 * 1、用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
 * 2、和 BFS 一样同样需要对已经遍历过的节点进行标记。
 *
 * dfs:深度优先搜索
 * bfs广度优先搜索一层一层遍历，每一层得到的所有新节点，都用队列存储起来以备下一次遍历的时候再遍历
 *
 * 而dfs深度优先搜索在得到一个新节点时立即对新节点进行遍历：
 * 从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；
 * 如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。
 * 返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
 *
 * 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
 * DFS 常用来求解这种 可达性 问题。
 *
 * 在程序实现 DFS 时需要考虑以下问题：
 * 1、用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
 * 2、和 BFS 一样同样需要对已经遍历过的节点进行标记。
 *
 * dfs:深度优先搜索
 * bfs广度优先搜索一层一层遍历，每一层得到的所有新节点，都用队列存储起来以备下一次遍历的时候再遍历
 *
 * 而dfs深度优先搜索在得到一个新节点时立即对新节点进行遍历：
 * 从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；
 * 如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。
 * 返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
 *
 * 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
 * DFS 常用来求解这种 可达性 问题。
 *
 * 在程序实现 DFS 时需要考虑以下问题：
 * 1、用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
 * 2、和 BFS 一样同样需要对已经遍历过的节点进行标记。
 *
 * dfs:深度优先搜索
 * bfs广度优先搜索一层一层遍历，每一层得到的所有新节点，都用队列存储起来以备下一次遍历的时候再遍历
 *
 * 而dfs深度优先搜索在得到一个新节点时立即对新节点进行遍历：
 * 从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；
 * 如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。
 * 返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
 *
 * 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
 * DFS 常用来求解这种 可达性 问题。
 *
 * 在程序实现 DFS 时需要考虑以下问题：
 * 1、用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
 * 2、和 BFS 一样同样需要对已经遍历过的节点进行标记。
 *
 * dfs:深度优先搜索
 * bfs广度优先搜索一层一层遍历，每一层得到的所有新节点，都用队列存储起来以备下一次遍历的时候再遍历
 *
 * 而dfs深度优先搜索在得到一个新节点时立即对新节点进行遍历：
 * 从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；
 * 如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。
 * 返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
 *
 * 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
 * DFS 常用来求解这种 可达性 问题。
 *
 * 在程序实现 DFS 时需要考虑以下问题：
 * 1、用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
 * 2、和 BFS 一样同样需要对已经遍历过的节点进行标记。
 */

/**
 * dfs:深度优先搜索
 * bfs广度优先搜索一层一层遍历，每一层得到的所有新节点，都用队列存储起来以备下一次遍历的时候再遍历
 *
 * 而dfs深度优先搜索在得到一个新节点时立即对新节点进行遍历：
 * 从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；
 * 如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。
 * 返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
 *
 * 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
 * DFS 常用来求解这种 可达性 问题。
 *
 * 在程序实现 DFS 时需要考虑以下问题：
 * 1、用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
 * 2、和 BFS 一样同样需要对已经遍历过的节点进行标记。
 * */

/**
 * [[0,0,1,0,0,0,0,1,0,0,0,0,0],
 *  [0,0,0,0,0,0,0,1,1,1,0,0,0],
 *  [0,1,1,0,1,0,0,0,0,0,0,0,0],
 *  [0,1,0,0,1,1,0,0,1,0,1,0,0],
 *  [0,1,0,0,1,1,0,0,1,1,1,0,0],
 *  [0,0,0,0,0,0,0,0,0,0,1,0,0],
 *  [0,0,0,0,0,0,0,1,1,1,0,0,0],
 *  [0,0,0,0,0,0,0,1,1,0,0,0,0]]
 *
 *  返回6
 * */

public class maxAreaOfIsland_695 {
    private static int m, n;
    private static int[][] direction = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    public static int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        m = grid.length;
        n = grid[0].length;  //定义行数和列数
        int maxArea = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                maxArea = Math.max(maxArea, dfs(grid, i, j));
            }
        }
        return maxArea;
    }

    //定义dfs搜索算法
    private static int dfs(int[][] grid, int r, int c) {
        if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 0) {
            return 0;
        }
        grid[r][c] = 0;  //标记，该元素已查过
        int area = 1;
        for (int[] d : direction) {
            area += dfs(grid, r + d[0], c + d[1]);
        }
        return area;
    }

    public static void main(String[] args) {
        int[][] grid = {{0, 1, 1}, {1, 0, 1}, {1, 1, 1}};
        System.out.println(maxAreaOfIsland(grid));
    }
}
